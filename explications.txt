
PARTIE 1  pseudo code

Fonction meilleur_combinaison(actions, max_cost):
    meilleur_combination = ListeVide
    meilleur_profit = 0
 Pour chaque combinaison possible de actions:
        cout_total = 0
        profit_total = 0
        
        Pour chaque action dans combinaison:
            cout_total += action['cout']
            profit_total += action['cout'] * action['benefice']

        Si cout_total <= max_cost et profit_total > meilleur_profit:
            meilleur_combination = combinaison
            meilleur_profit = profit_total

    Retourner meilleur_combination, meilleur_profit


processus itératif de génération de toutes les combinaisons possibles d'actions, calculant le coût total et le profit total pour chaque combinaison, 
en mettant à jour la meilleure combinaison et le meilleur profit si une combinaison respecte les conditions.

Complexité Temporelle : lineaire
O(2n×investment_limit) : La complexité dépend exponentiellement du nombre d'actions (2n)en raison de l'exploration exhaustive de toutes les combinaisons possibles.
La limite d'investissement (investment_limitinvestment_limit) contribue à la complexité globale.


Complexité Spatiale : Polynomiale
O(n×investment_limit) La complexité spatiale dépend linéairement du nombre d'actions (n) et de la limite d'investissement ((investment_limit). Cela est dû à la profondeur maximale de la récursion, qui est fonction du nombre d'actions.
Ces analyses mettent en évidence le fait que l'algorithme a une complexité exponentielle en raison de l'exploration exhaustive de toutes les combinaisons possibles. Cela signifie que sa performance peut se dégrader rapidement à mesure que le nombre d'actions augmente. Si le nombre d'actions est élevé, il peut être intéressant d'explorer des approches d'optimisation plus efficaces pour résoudre le problème.


PARTIE 2  pseudo code

Initialisation de la Matrice DP (Tableau de Programmation Dynamique) :

La matrice dp est une table à deux dimensions où dp[i][j] représente le profit maximal obtenu avec les i premières actions et un budget de j.
Double Boucle de Remplissage de la Matrice DP :

On parcourt chaque action et chaque budget possible pour calculer le profit maximal pouvant être obtenu jusqu'à cet état.
Les indices i et j de la boucle externe et interne représentent respectivement le nombre d'actions considérées et le budget disponible.
Calcul du Profit pour chaque Case de la Matrice :

Pour chaque action i et budget j, on a deux choix :
Exclure l'action i : Le profit reste le même que pour i-1 actions avec le même budget, donc dp[i][j] = dp[i-1][j].
Inclure l'action i : On ajoute le profit de l'action i au profit obtenu avec i-1 actions et un budget réduit de cost[i] (coût de l'action i), donc dp[i][j] = dp[i-1][j-cost[i]] + cost[i] * benefit[i].
Choix du Meilleur Profit :

Pour chaque état (i, j), on choisit le maximum entre les deux choix ci-dessus.
dp[i][j] contient donc le profit maximal pour les i premières actions et un budget de j.
Reconstruction de la Solution (Actions Sélectionnées) :

On commence par la case en bas à droite de la matrice dp (dp[n][max_budget]) et on remonte pour reconstruire les actions sélectionnées.
Affichage de la Solution :

On affiche les actions sélectionnées avec leurs coûts et bénéfices, ainsi que le coût total et le profit total.






Fonction maximiser_profit_dynamique(actions, max_budget):
    n = longueur(actions)
    dp = tableau 2D de taille (n + 1) x (max_budget + 1)

    Pour chaque i allant de 1 à n:
        Pour chaque budget allant de 0 à max_budget:
            cout = actions[i - 1]["cout"]
            benefice = actions[i - 1]["benefice"]

            # Ne pas inclure l'action i
            exclude_action_i = dp[i - 1][budget]

            # Inclure l'action i si possible
            Si budget >= cout:
                include_action_i = dp[i - 1][budget - cout] + cout * benefice
            Sinon:
                include_action_i = 0

            # Choix entre inclusion et exclusion
            dp[i][budget] = maximum(exclude_action_i, include_action_i)

    # Reconstruire la solution optimale
    resultat_final = {"actions_selectionnees": [], "profit_total": dp[n][max_budget]}
    budget_restant = max_budget

    Pour i allant de n à 1 (en ordre décroissant):
        Si dp[i][budget_restant] != dp[i - 1][budget_restant]:
            action_i = actions[i - 1]
            resultat_final["actions_selectionnees"].ajouter(action_i)
            budget_restant -= action_i["cout"]

    Retourner resultat_final
